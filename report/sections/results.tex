\section{Results}

\begin{figure}[H]
\input{Fig/traj3.tex}
\caption{Positions and inputs from a sample test}\label{fig:traj}
\end{figure}


\subsection{Discussion}
\autoref{fig:traj} shows a sample of recorded positions and inputs from a test. In summary, all performance criteria were met apart from the violation of the travel bound at the beginning of the trajectory. The overshoot bounds are illustrated with dashed lines, and the transition points are indicated by the arrow markers whose gaps correspond to the settling specification at that time. Input saturation happens briefly at the beginning of the test and during the initiation of a transition. In the test shown in \autoref{fig:traj}, $U_a$ is saturated for 0.025\% of the trajectory, and $U_b$ for 0.725\%.

\subsubsection{Travel Bound Violation}
On every test, the system violated the travel bound of +20$^{\circ}$, this seems almost independent of adjustments to the model values and controller tuning. Though the travel and pitch start at roughly zero, applying equal thrust to the fans (as shown at the very beginning of the input plot) causes the travel axis to move, and it settles to zero travel velocity with a nonzero pitch---this indicates an imbalance in the helicopter somewhere. Investigating the response when the pitch angle starts facing slightly the other way, it was observed that it still moves the travel axis in the opposite direction, which suggests that it is independent of the pitch angle. Similarly, the travel axis moves when the fans stop spinning, but not when dropped by hand. 

A plausible explanation for this behaviour is to consider the inertia of the fan blades: as they spin up, conservation of angular momentum should cause the travel axis to rotate in the opposite direction. The rotational directions of the fans and the travel axis perturbation are opposite---consistent with this theory. Furthermore, the trajectory consistently lags behind the reference only on the return transition (which can be seen in~\autoref{fig:traj}), where it is having to push against this torque; since this is not modelled in the simulation, it does not exhibit this behaviour, despite the rest of the trajectory being closely representative of the test.

Since the fans start at full thrust, inertia is quickly imparted into the axis; this can be partially resolved by detuning the elevation axis gains, but at the expense of tracking performance. A better option may be to have a smooth reference from the initial elevation to reduce the initial thrust to allow more time for the controller to compensate. The ideal solution (if this is the correct explanation) would be to use fans that spin in opposing directions. 

This effect could be modelled and included in the state space system: the torque exerted by the fans on the travel axis is proportional to their angular accelerations and current draws. Therefore, this could be approximated onboard using a current sensor on the fans, or (less reliably) via state estimation. Since the fan force is proportional to the blade velocity (hence $V_{a,b}$), then the rate of change of the fan force is proportional to the blade acceleration. A second-order fan model is sufficient to model this effect, where $\frac{d \dot{\Theta}}{d t}$ is related to $\dot{V}_{a,b}$, which are estimated by the Kalman Filter; whole-system observability holds for this alteration and would require the addition of only two states.

\subsubsection{Optimal Reference Generator}
One of the key advantages of the full-state reference in comparison to the FIR method is the inclusion of the pitch and pitch rate references, as this is the principle axis of the fans. The pitch rate commands are very effective at initiating the transition; without them, the travel axis lags behind the reference, and overshoot increases. A model-based algorithm is required for a dynamically feasible full-state trajectory. However, the issue of an embedded implementation of the optimisation algorithm remains. Though it can be feasibly implemented on \emph{an} embedded system, it certainly could not be implemented on the myDAQ with any reasonable performance. Either it could remain as an offline computation, or it could be approximated as a quadratic program, which can be implemented on embedded platforms at high speed---this would involve trading off some freedom in the problem formulation.